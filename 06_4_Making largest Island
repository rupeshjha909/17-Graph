import java.util.*;

public class FloodFill {
    private static final int N = 100;
    
    // Global arrays
    private static int[][] a = new int[N][N];
    private static int[][] vis = new int[N][N];
    private static int[] colCnt = new int[N];
    
    private static int n, m;
    
    // Direction arrays for 4-directional movement
    private static int[] dx = {0, 0, 1, -1};
    private static int[] dy = {1, -1, 0, 0};
    
    private static void floodFill(int x, int y, int col) {
        a[x][y] = col;
        colCnt[col]++;
        vis[x][y] = 1;
        
        for (int i = 0; i < 4; i++) {
            int xx = x + dx[i];
            int yy = y + dy[i];
            
            if (xx >= 0 && xx < n && yy >= 0 && yy < m && 
                vis[xx][yy] == 0 && a[xx][yy] == 1) {
                floodFill(xx, yy, col);
            }
        }
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        n = scanner.nextInt();
        m = scanner.nextInt();
        
        // Read the grid
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                a[i][j] = scanner.nextInt();
            }
        }
        
        int totalCount = 0;
        
        // Find all islands using flood fill
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (a[i][j] == 1 && vis[i][j] == 0) {
                    totalCount++;
                    floodFill(i, j, totalCount);
                }
            }
        }
        
        int largestIsland = 0;
        
        // Find the largest existing island
        for (int i = 1; i <= totalCount; i++) {
            largestIsland = Math.max(largestIsland, colCnt[i]);
        }
        
        // Check if we can create a larger island by converting a 0 to 1
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (a[i][j] == 0) {
                    // Can be converted - check adjacent islands
                    Set<Integer> uniqueColors = new HashSet<>();
                    
                    for (int k = 0; k < 4; k++) {
                        int ii = i + dx[k];
                        int jj = j + dy[k];
                        
                        if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                            uniqueColors.add(a[ii][jj]);
                        }
                    }
                    
                    int ans = 1; // We have changed one cell (0 to 1)
                    for (int color : uniqueColors) {
                        ans += colCnt[color];
                    }
                    
                    largestIsland = Math.max(largestIsland, ans);
                }
            }
        }
        
        System.out.println(largestIsland);
        scanner.close();
    }
}



const int N = 100;

int a[N][N], vis[N][N];
int col_cnt[N];

int n, m;

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

void flood_fill(int x, int y, int col) {
	a[x][y] = col;
	col_cnt[col]++;
	vis[x][y] = 1;
	for (int i = 0; i < 4; i++) {
		int xx = x + dx[i];
		int yy = y + dy[i];
		if (xx >= 0 && xx < n && yy >= 0 && yy < m && vis[xx][yy] == 0 && a[xx][yy] == 1) {
			flood_fill(xx, yy, col);
		}
	}
}

int main()
{
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> a[i][j];
		}
	}

	int total_count = 0;

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (a[i][j] == 1 && vis[i][j] == 0) {
				total_count++;
				flood_fill(i, j, total_count);
			}
		}
	}

	int largest_island = 0;

	for (int i = 1; i <= total_count; i++) {
		largest_island = max(largest_island, col_cnt[i]);
	}

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (a[i][j] == 0) {
				// can be converted
				set<int> St;//taking to store unique color
				for (int k = 0; k < 4; k++) {
					//going to nearby all the 4 cell and store unique in set
					int ii = i + dx[k];
					int jj = j + dy[k];
					if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
						St.insert(a[ii][jj]);
					}
				}
				int ans = 1;//we have changed one cell
				for (auto x : St) {
					ans += col_cnt[x];
				}
				largest_island = max(largest_island, ans);
			}
		}
	}

	cout << largest_island;

	return 0;
}
