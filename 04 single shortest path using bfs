// Function to return Breadth First Search Traversal of given graph.
    public ArrayList<Integer> shortestPath(ArrayList<ArrayList<Integer>> adjacencyList, int src) {
    int v = adjacencyList.size();
    ArrayList<Integer> dist = new ArrayList<>();
    
    // Initialize distances with Integer.MAX_VALUE (equivalent to INT_MAX)
    for (int i = 0; i < v; i++) {
        dist.add(Integer.MAX_VALUE);
    }
    
    // Queue for BFS traversal
    Queue<Integer> queue = new ArrayDeque<>();
    queue.add(src);
    dist.set(src, 0);
    
    while (!queue.isEmpty()) {
        int node = queue.poll();
        
        // Get neighbors of current node
        ArrayList<Integer> neighbors = adjacencyList.get(node);
        if (neighbors != null) {
            for (int neighbor : neighbors) {
                if (dist.get(neighbor) == Integer.MAX_VALUE) {
                    dist.set(neighbor, dist.get(node) + 1);
                    queue.add(neighbor);
                }
            }
        }
    }
    
    return dist;
}



class Solution
{
public:
	// Function to find the shortest path from source to all other nodes
	vector<int> shortestPath(vector<vector<int>> &adj, int src)
	{
		// code here
		int v = adj.size();
		vector<int> dist(v,INT_MAX);
		queue<int> q;
		q.push(src);
		dist[src] = 0;
		while(!q.empty()){
			int node = q.front();
			q.pop();
			for(auto neighbour:adj[node]){
				if(dist[neighbour]==INT_MAX){
					dist[neighbour] = dist[node] + 1;
					q.push(neighbour);
				}
			}
		}
		return dist;
	}
};


int main()
{
	// Redirect input and output
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
	// input for this
	int v, e;
	cin >> v >> e;
	vector<vector<int>> adj(v);
	for(int i=0;i<e;i++){
		int u, v;
		cin >> u >> v;
		adj[u].pb(v);
		adj[v].pb(u);
	}

	Solution s;
	vector<int> dist = s.shortestPath(adj, 0);
	for (int i = 0; i < v;i++)
	{
		cout <<"dist from 0 to " << i << " is " << dist[i] << endl;
	}
	return 0;
}
